import re

# Token types
INTEGER = 'INTEGER'
PLUS = 'PLUS'
MINUS = 'MINUS'
MULTIPLY = 'MULTIPLY'
DIVIDE = 'DIVIDE'
LPAREN = 'LPAREN'
RPAREN = 'RPAREN'
EOF = 'EOF'

# token generated by the lexer
class Token:
    def __init__(self, type, value=None):
        self.type = type
        self.value = value

    def __repr__(self):
        if self.value:
            return f"{self.type}({self.value})"
        return f"{self.type}"

# Abstract Syntax Tree node representing a binary operation
class AST:
    pass

# Node representing a binary operation
class BinOp(AST):
    def __init__(self, left, op, right):
        self.left = left
        self.op = op
        self.right = right

# Node representing a numeric value
class Num(AST):
    def __init__(self, token):
        self.token = token
        self.value = token.value

# Lexer class to tokenize the input text
class Lexer:
    def __init__(self, text):
        self.tokens = []
        self.text = text
        self.pos = 0
        self.current_char = self.text[self.pos]

        # Regular expressions for token types
        TOKENS = {
            INTEGER: r'\d+',
            PLUS: r'\+',
            MINUS: r'-',
            MULTIPLY: r'\*',
            DIVIDE: r'/',
            LPAREN: r'\(',
            RPAREN: r'\)',
        }
        # Compile regular expressions into a single regex pattern
        self.token_regex = re.compile('|'.join(f'(?P<{name}>{regex})' for name, regex in TOKENS.items()))

    # Raises an exception for invalid characters
    def error(self):
        raise Exception('Invalid character')

    # Move to the next character in the input text
    def advance(self):
        self.pos += 1
        if self.pos > len(self.text) - 1:
            self.current_char = None
        else:
            self.current_char = self.text[self.pos]

    # Skip whitespace characters
    def skip_whitespace(self):
        while self.current_char is not None and self.current_char.isspace():
            self.advance()

    # Generate next token from input text
    def get_next_token(self):
        while self.current_char is not None:
            match = self.token_regex.match(self.text, self.pos)
            if match:
                token_type = match.lastgroup
                token_value = match.group(token_type)
                if token_type == INTEGER:
                    token_value = int(token_value)
                token = Token(token_type, token_value)
                self.tokens.append(token)
                self.pos = match.end()
                self.current_char = self.text[self.pos] if self.pos < len(self.text) else None
                continue

            if self.current_char.isspace():
                self.skip_whitespace()
                continue

            self.error()

        return Token(EOF)

# Parser class to build Abstract Syntax Tree (AST) from tokens
class Parser:
    def __init__(self, lexer):
        self.lexer = lexer
        self.current_token = self.lexer.get_next_token()

    # Raises an exception for syntax errors
    def error(self):
        raise Exception('Invalid syntax')

    # Consume the current token if it matches the given token type
    def eat(self, token_type):
        if self.current_token.type == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            self.error()

    # Parse factor (number or expression within parentheses)
    def factor(self):
        token = self.current_token
        if token.type == INTEGER:
            self.eat(INTEGER)
            return Num(token)
        elif token.type == LPAREN:
            self.eat(LPAREN)
            node = self.expr()
            self.eat(RPAREN)
            return node
        else:
            self.error()

    # Parse term (sequence of factors with multiplication or division)
    def term(self):
        node = self.factor()
        while self.current_token.type in (MULTIPLY, DIVIDE):
            token = self.current_token
            self.eat(token.type)
            node = BinOp(left=node, op=token, right=self.factor())
        return node

    # Parse expression (sequence of terms with addition or subtraction)
    def expr(self):
        node = self.term()
        while self.current_token.type in (PLUS, MINUS):
            token = self.current_token
            self.eat(token.type)
            node = BinOp(left=node, op=token, right=self.term())
        return node

    # Print the AST tree (for debugging purposes)
    def print_tree(self, node, level=0):
        if isinstance(node, Num):
            print("  " * level + repr(node))
        elif isinstance(node, BinOp):
            print("  " * level + repr(node.op))
            self.print_tree(node.left, level + 1)
            self.print_tree(node.right, level + 1)

# Visitor class to traverse the AST and perform operations
class NodeVisitor:
    def visit(self, node):
        method_name = f'visit_{type(node).__name__}'
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        raise Exception(f'No visit_{type(node).__name__} method defined')

# Interpreter class to evaluate expressions using the AST
class Interpreter(NodeVisitor):
    def __init__(self, parser):
        self.parser = parser

    # Visit method for BinOp nodes
    def visit_BinOp(self, node):
        if node.op.type == PLUS:
            return self.visit(node.left) + self.visit(node.right)
        elif node.op.type == MINUS:
            return self.visit(node.left) - self.visit(node.right)
        elif node.op.type == MULTIPLY:
            return self.visit(node.left) * self.visit(node.right)
        elif node.op.type == DIVIDE:
            return self.visit(node.left) / self.visit(node.right)

    # Visit method for Num nodes
    def visit_Num(self, node):
        return node.value

    # Interpret the input expression
    def interpret(self):
        tree = self.parser.expr()
        return self.visit(tree)

